// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: solution.proto

#ifndef PROTOBUF_solution_2eproto__INCLUDED
#define PROTOBUF_solution_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pagmo {
namespace problem {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_solution_2eproto();
void protobuf_AssignDesc_solution_2eproto();
void protobuf_ShutdownFile_solution_2eproto();

class TransXTimes;
class TransXEscape;
class TransXDSM;
class TransXFlyBy;
class TransXArrival;
class TransXSolution;

// ===================================================================

class TransXTimes : public ::google::protobuf::Message {
 public:
  TransXTimes();
  virtual ~TransXTimes();

  TransXTimes(const TransXTimes& from);

  inline TransXTimes& operator=(const TransXTimes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransXTimes& default_instance();

  void Swap(TransXTimes* other);

  // implements Message ----------------------------------------------

  TransXTimes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransXTimes& from);
  void MergeFrom(const TransXTimes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string planets = 1;
  inline int planets_size() const;
  inline void clear_planets();
  static const int kPlanetsFieldNumber = 1;
  inline const ::std::string& planets(int index) const;
  inline ::std::string* mutable_planets(int index);
  inline void set_planets(int index, const ::std::string& value);
  inline void set_planets(int index, const char* value);
  inline void set_planets(int index, const char* value, size_t size);
  inline ::std::string* add_planets();
  inline void add_planets(const ::std::string& value);
  inline void add_planets(const char* value);
  inline void add_planets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& planets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_planets();

  // repeated double times = 2;
  inline int times_size() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline double times(int index) const;
  inline void set_times(int index, double value);
  inline void add_times(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      times() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_times();

  // @@protoc_insertion_point(class_scope:pagmo.problem.TransXTimes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> planets_;
  ::google::protobuf::RepeatedField< double > times_;
  friend void  protobuf_AddDesc_solution_2eproto();
  friend void protobuf_AssignDesc_solution_2eproto();
  friend void protobuf_ShutdownFile_solution_2eproto();

  void InitAsDefaultInstance();
  static TransXTimes* default_instance_;
};
// -------------------------------------------------------------------

class TransXEscape : public ::google::protobuf::Message {
 public:
  TransXEscape();
  virtual ~TransXEscape();

  TransXEscape(const TransXEscape& from);

  inline TransXEscape& operator=(const TransXEscape& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransXEscape& default_instance();

  void Swap(TransXEscape* other);

  // implements Message ----------------------------------------------

  TransXEscape* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransXEscape& from);
  void MergeFrom(const TransXEscape& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double mjd = 1;
  inline bool has_mjd() const;
  inline void clear_mjd();
  static const int kMjdFieldNumber = 1;
  inline double mjd() const;
  inline void set_mjd(double value);

  // required double vinf = 2;
  inline bool has_vinf() const;
  inline void clear_vinf();
  static const int kVinfFieldNumber = 2;
  inline double vinf() const;
  inline void set_vinf(double value);

  // required double burn = 3;
  inline bool has_burn() const;
  inline void clear_burn();
  static const int kBurnFieldNumber = 3;
  inline double burn() const;
  inline void set_burn(double value);

  // required double prograde = 4;
  inline bool has_prograde() const;
  inline void clear_prograde();
  static const int kProgradeFieldNumber = 4;
  inline double prograde() const;
  inline void set_prograde(double value);

  // required double outward = 5;
  inline bool has_outward() const;
  inline void clear_outward();
  static const int kOutwardFieldNumber = 5;
  inline double outward() const;
  inline void set_outward(double value);

  // required double plane = 6;
  inline bool has_plane() const;
  inline void clear_plane();
  static const int kPlaneFieldNumber = 6;
  inline double plane() const;
  inline void set_plane(double value);

  // required string planet = 20;
  inline bool has_planet() const;
  inline void clear_planet();
  static const int kPlanetFieldNumber = 20;
  inline const ::std::string& planet() const;
  inline void set_planet(const ::std::string& value);
  inline void set_planet(const char* value);
  inline void set_planet(const char* value, size_t size);
  inline ::std::string* mutable_planet();
  inline ::std::string* release_planet();
  inline void set_allocated_planet(::std::string* planet);

  // @@protoc_insertion_point(class_scope:pagmo.problem.TransXEscape)
 private:
  inline void set_has_mjd();
  inline void clear_has_mjd();
  inline void set_has_vinf();
  inline void clear_has_vinf();
  inline void set_has_burn();
  inline void clear_has_burn();
  inline void set_has_prograde();
  inline void clear_has_prograde();
  inline void set_has_outward();
  inline void clear_has_outward();
  inline void set_has_plane();
  inline void clear_has_plane();
  inline void set_has_planet();
  inline void clear_has_planet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double mjd_;
  double vinf_;
  double burn_;
  double prograde_;
  double outward_;
  double plane_;
  ::std::string* planet_;
  friend void  protobuf_AddDesc_solution_2eproto();
  friend void protobuf_AssignDesc_solution_2eproto();
  friend void protobuf_ShutdownFile_solution_2eproto();

  void InitAsDefaultInstance();
  static TransXEscape* default_instance_;
};
// -------------------------------------------------------------------

class TransXDSM : public ::google::protobuf::Message {
 public:
  TransXDSM();
  virtual ~TransXDSM();

  TransXDSM(const TransXDSM& from);

  inline TransXDSM& operator=(const TransXDSM& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransXDSM& default_instance();

  void Swap(TransXDSM* other);

  // implements Message ----------------------------------------------

  TransXDSM* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransXDSM& from);
  void MergeFrom(const TransXDSM& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double mjd = 1;
  inline bool has_mjd() const;
  inline void clear_mjd();
  static const int kMjdFieldNumber = 1;
  inline double mjd() const;
  inline void set_mjd(double value);

  // required double vinf = 2;
  inline bool has_vinf() const;
  inline void clear_vinf();
  static const int kVinfFieldNumber = 2;
  inline double vinf() const;
  inline void set_vinf(double value);

  // required double burn = 3;
  inline bool has_burn() const;
  inline void clear_burn();
  static const int kBurnFieldNumber = 3;
  inline double burn() const;
  inline void set_burn(double value);

  // required double prograde = 4;
  inline bool has_prograde() const;
  inline void clear_prograde();
  static const int kProgradeFieldNumber = 4;
  inline double prograde() const;
  inline void set_prograde(double value);

  // required double outward = 5;
  inline bool has_outward() const;
  inline void clear_outward();
  static const int kOutwardFieldNumber = 5;
  inline double outward() const;
  inline void set_outward(double value);

  // required double plane = 6;
  inline bool has_plane() const;
  inline void clear_plane();
  static const int kPlaneFieldNumber = 6;
  inline double plane() const;
  inline void set_plane(double value);

  // @@protoc_insertion_point(class_scope:pagmo.problem.TransXDSM)
 private:
  inline void set_has_mjd();
  inline void clear_has_mjd();
  inline void set_has_vinf();
  inline void clear_has_vinf();
  inline void set_has_burn();
  inline void clear_has_burn();
  inline void set_has_prograde();
  inline void clear_has_prograde();
  inline void set_has_outward();
  inline void clear_has_outward();
  inline void set_has_plane();
  inline void clear_has_plane();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double mjd_;
  double vinf_;
  double burn_;
  double prograde_;
  double outward_;
  double plane_;
  friend void  protobuf_AddDesc_solution_2eproto();
  friend void protobuf_AssignDesc_solution_2eproto();
  friend void protobuf_ShutdownFile_solution_2eproto();

  void InitAsDefaultInstance();
  static TransXDSM* default_instance_;
};
// -------------------------------------------------------------------

class TransXFlyBy : public ::google::protobuf::Message {
 public:
  TransXFlyBy();
  virtual ~TransXFlyBy();

  TransXFlyBy(const TransXFlyBy& from);

  inline TransXFlyBy& operator=(const TransXFlyBy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransXFlyBy& default_instance();

  void Swap(TransXFlyBy* other);

  // implements Message ----------------------------------------------

  TransXFlyBy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransXFlyBy& from);
  void MergeFrom(const TransXFlyBy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double mjd = 1;
  inline bool has_mjd() const;
  inline void clear_mjd();
  static const int kMjdFieldNumber = 1;
  inline double mjd() const;
  inline void set_mjd(double value);

  // required double burn = 3;
  inline bool has_burn() const;
  inline void clear_burn();
  static const int kBurnFieldNumber = 3;
  inline double burn() const;
  inline void set_burn(double value);

  // required double prograde = 4;
  inline bool has_prograde() const;
  inline void clear_prograde();
  static const int kProgradeFieldNumber = 4;
  inline double prograde() const;
  inline void set_prograde(double value);

  // required double outward = 5;
  inline bool has_outward() const;
  inline void clear_outward();
  static const int kOutwardFieldNumber = 5;
  inline double outward() const;
  inline void set_outward(double value);

  // required double plane = 6;
  inline bool has_plane() const;
  inline void clear_plane();
  static const int kPlaneFieldNumber = 6;
  inline double plane() const;
  inline void set_plane(double value);

  // required double approach_vel = 7;
  inline bool has_approach_vel() const;
  inline void clear_approach_vel();
  static const int kApproachVelFieldNumber = 7;
  inline double approach_vel() const;
  inline void set_approach_vel(double value);

  // required double departure_vel = 8;
  inline bool has_departure_vel() const;
  inline void clear_departure_vel();
  static const int kDepartureVelFieldNumber = 8;
  inline double departure_vel() const;
  inline void set_departure_vel(double value);

  // required double outward_angle = 9;
  inline bool has_outward_angle() const;
  inline void clear_outward_angle();
  static const int kOutwardAngleFieldNumber = 9;
  inline double outward_angle() const;
  inline void set_outward_angle(double value);

  // required double inclination = 10;
  inline bool has_inclination() const;
  inline void clear_inclination();
  static const int kInclinationFieldNumber = 10;
  inline double inclination() const;
  inline void set_inclination(double value);

  // required double turning_angle = 11;
  inline bool has_turning_angle() const;
  inline void clear_turning_angle();
  static const int kTurningAngleFieldNumber = 11;
  inline double turning_angle() const;
  inline void set_turning_angle(double value);

  // required double periapsis_altitude = 12;
  inline bool has_periapsis_altitude() const;
  inline void clear_periapsis_altitude();
  static const int kPeriapsisAltitudeFieldNumber = 12;
  inline double periapsis_altitude() const;
  inline void set_periapsis_altitude(double value);

  // required string planet = 20;
  inline bool has_planet() const;
  inline void clear_planet();
  static const int kPlanetFieldNumber = 20;
  inline const ::std::string& planet() const;
  inline void set_planet(const ::std::string& value);
  inline void set_planet(const char* value);
  inline void set_planet(const char* value, size_t size);
  inline ::std::string* mutable_planet();
  inline ::std::string* release_planet();
  inline void set_allocated_planet(::std::string* planet);

  // @@protoc_insertion_point(class_scope:pagmo.problem.TransXFlyBy)
 private:
  inline void set_has_mjd();
  inline void clear_has_mjd();
  inline void set_has_burn();
  inline void clear_has_burn();
  inline void set_has_prograde();
  inline void clear_has_prograde();
  inline void set_has_outward();
  inline void clear_has_outward();
  inline void set_has_plane();
  inline void clear_has_plane();
  inline void set_has_approach_vel();
  inline void clear_has_approach_vel();
  inline void set_has_departure_vel();
  inline void clear_has_departure_vel();
  inline void set_has_outward_angle();
  inline void clear_has_outward_angle();
  inline void set_has_inclination();
  inline void clear_has_inclination();
  inline void set_has_turning_angle();
  inline void clear_has_turning_angle();
  inline void set_has_periapsis_altitude();
  inline void clear_has_periapsis_altitude();
  inline void set_has_planet();
  inline void clear_has_planet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double mjd_;
  double burn_;
  double prograde_;
  double outward_;
  double plane_;
  double approach_vel_;
  double departure_vel_;
  double outward_angle_;
  double inclination_;
  double turning_angle_;
  double periapsis_altitude_;
  ::std::string* planet_;
  friend void  protobuf_AddDesc_solution_2eproto();
  friend void protobuf_AssignDesc_solution_2eproto();
  friend void protobuf_ShutdownFile_solution_2eproto();

  void InitAsDefaultInstance();
  static TransXFlyBy* default_instance_;
};
// -------------------------------------------------------------------

class TransXArrival : public ::google::protobuf::Message {
 public:
  TransXArrival();
  virtual ~TransXArrival();

  TransXArrival(const TransXArrival& from);

  inline TransXArrival& operator=(const TransXArrival& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransXArrival& default_instance();

  void Swap(TransXArrival* other);

  // implements Message ----------------------------------------------

  TransXArrival* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransXArrival& from);
  void MergeFrom(const TransXArrival& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double mjd = 1;
  inline bool has_mjd() const;
  inline void clear_mjd();
  static const int kMjdFieldNumber = 1;
  inline double mjd() const;
  inline void set_mjd(double value);

  // required double vinf = 2;
  inline bool has_vinf() const;
  inline void clear_vinf();
  static const int kVinfFieldNumber = 2;
  inline double vinf() const;
  inline void set_vinf(double value);

  // required double burn = 3;
  inline bool has_burn() const;
  inline void clear_burn();
  static const int kBurnFieldNumber = 3;
  inline double burn() const;
  inline void set_burn(double value);

  // required string planet = 20;
  inline bool has_planet() const;
  inline void clear_planet();
  static const int kPlanetFieldNumber = 20;
  inline const ::std::string& planet() const;
  inline void set_planet(const ::std::string& value);
  inline void set_planet(const char* value);
  inline void set_planet(const char* value, size_t size);
  inline ::std::string* mutable_planet();
  inline ::std::string* release_planet();
  inline void set_allocated_planet(::std::string* planet);

  // @@protoc_insertion_point(class_scope:pagmo.problem.TransXArrival)
 private:
  inline void set_has_mjd();
  inline void clear_has_mjd();
  inline void set_has_vinf();
  inline void clear_has_vinf();
  inline void set_has_burn();
  inline void clear_has_burn();
  inline void set_has_planet();
  inline void clear_has_planet();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double mjd_;
  double vinf_;
  double burn_;
  ::std::string* planet_;
  friend void  protobuf_AddDesc_solution_2eproto();
  friend void protobuf_AssignDesc_solution_2eproto();
  friend void protobuf_ShutdownFile_solution_2eproto();

  void InitAsDefaultInstance();
  static TransXArrival* default_instance_;
};
// -------------------------------------------------------------------

class TransXSolution : public ::google::protobuf::Message {
 public:
  TransXSolution();
  virtual ~TransXSolution();

  TransXSolution(const TransXSolution& from);

  inline TransXSolution& operator=(const TransXSolution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TransXSolution& default_instance();

  void Swap(TransXSolution* other);

  // implements Message ----------------------------------------------

  TransXSolution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TransXSolution& from);
  void MergeFrom(const TransXSolution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double x = 1;
  inline int x_size() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline double x(int index) const;
  inline void set_x(int index, double value);
  inline void add_x(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      x() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_x();

  // required string problem = 2;
  inline bool has_problem() const;
  inline void clear_problem();
  static const int kProblemFieldNumber = 2;
  inline const ::std::string& problem() const;
  inline void set_problem(const ::std::string& value);
  inline void set_problem(const char* value);
  inline void set_problem(const char* value, size_t size);
  inline ::std::string* mutable_problem();
  inline ::std::string* release_problem();
  inline void set_allocated_problem(::std::string* problem);

  // required double fuel_cost = 3;
  inline bool has_fuel_cost() const;
  inline void clear_fuel_cost();
  static const int kFuelCostFieldNumber = 3;
  inline double fuel_cost() const;
  inline void set_fuel_cost(double value);

  // required .pagmo.problem.TransXTimes times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline const ::pagmo::problem::TransXTimes& times() const;
  inline ::pagmo::problem::TransXTimes* mutable_times();
  inline ::pagmo::problem::TransXTimes* release_times();
  inline void set_allocated_times(::pagmo::problem::TransXTimes* times);

  // required .pagmo.problem.TransXEscape escape = 5;
  inline bool has_escape() const;
  inline void clear_escape();
  static const int kEscapeFieldNumber = 5;
  inline const ::pagmo::problem::TransXEscape& escape() const;
  inline ::pagmo::problem::TransXEscape* mutable_escape();
  inline ::pagmo::problem::TransXEscape* release_escape();
  inline void set_allocated_escape(::pagmo::problem::TransXEscape* escape);

  // repeated .pagmo.problem.TransXDSM dsms = 6;
  inline int dsms_size() const;
  inline void clear_dsms();
  static const int kDsmsFieldNumber = 6;
  inline const ::pagmo::problem::TransXDSM& dsms(int index) const;
  inline ::pagmo::problem::TransXDSM* mutable_dsms(int index);
  inline ::pagmo::problem::TransXDSM* add_dsms();
  inline const ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXDSM >&
      dsms() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXDSM >*
      mutable_dsms();

  // repeated .pagmo.problem.TransXFlyBy flybyes = 7;
  inline int flybyes_size() const;
  inline void clear_flybyes();
  static const int kFlybyesFieldNumber = 7;
  inline const ::pagmo::problem::TransXFlyBy& flybyes(int index) const;
  inline ::pagmo::problem::TransXFlyBy* mutable_flybyes(int index);
  inline ::pagmo::problem::TransXFlyBy* add_flybyes();
  inline const ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXFlyBy >&
      flybyes() const;
  inline ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXFlyBy >*
      mutable_flybyes();

  // required .pagmo.problem.TransXArrival arrival = 8;
  inline bool has_arrival() const;
  inline void clear_arrival();
  static const int kArrivalFieldNumber = 8;
  inline const ::pagmo::problem::TransXArrival& arrival() const;
  inline ::pagmo::problem::TransXArrival* mutable_arrival();
  inline ::pagmo::problem::TransXArrival* release_arrival();
  inline void set_allocated_arrival(::pagmo::problem::TransXArrival* arrival);

  // @@protoc_insertion_point(class_scope:pagmo.problem.TransXSolution)
 private:
  inline void set_has_problem();
  inline void clear_has_problem();
  inline void set_has_fuel_cost();
  inline void clear_has_fuel_cost();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_escape();
  inline void clear_has_escape();
  inline void set_has_arrival();
  inline void clear_has_arrival();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > x_;
  ::std::string* problem_;
  double fuel_cost_;
  ::pagmo::problem::TransXTimes* times_;
  ::pagmo::problem::TransXEscape* escape_;
  ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXDSM > dsms_;
  ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXFlyBy > flybyes_;
  ::pagmo::problem::TransXArrival* arrival_;
  friend void  protobuf_AddDesc_solution_2eproto();
  friend void protobuf_AssignDesc_solution_2eproto();
  friend void protobuf_ShutdownFile_solution_2eproto();

  void InitAsDefaultInstance();
  static TransXSolution* default_instance_;
};
// ===================================================================


// ===================================================================

// TransXTimes

// repeated string planets = 1;
inline int TransXTimes::planets_size() const {
  return planets_.size();
}
inline void TransXTimes::clear_planets() {
  planets_.Clear();
}
inline const ::std::string& TransXTimes::planets(int index) const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXTimes.planets)
  return planets_.Get(index);
}
inline ::std::string* TransXTimes::mutable_planets(int index) {
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXTimes.planets)
  return planets_.Mutable(index);
}
inline void TransXTimes::set_planets(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXTimes.planets)
  planets_.Mutable(index)->assign(value);
}
inline void TransXTimes::set_planets(int index, const char* value) {
  planets_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pagmo.problem.TransXTimes.planets)
}
inline void TransXTimes::set_planets(int index, const char* value, size_t size) {
  planets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pagmo.problem.TransXTimes.planets)
}
inline ::std::string* TransXTimes::add_planets() {
  return planets_.Add();
}
inline void TransXTimes::add_planets(const ::std::string& value) {
  planets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pagmo.problem.TransXTimes.planets)
}
inline void TransXTimes::add_planets(const char* value) {
  planets_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pagmo.problem.TransXTimes.planets)
}
inline void TransXTimes::add_planets(const char* value, size_t size) {
  planets_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pagmo.problem.TransXTimes.planets)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TransXTimes::planets() const {
  // @@protoc_insertion_point(field_list:pagmo.problem.TransXTimes.planets)
  return planets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TransXTimes::mutable_planets() {
  // @@protoc_insertion_point(field_mutable_list:pagmo.problem.TransXTimes.planets)
  return &planets_;
}

// repeated double times = 2;
inline int TransXTimes::times_size() const {
  return times_.size();
}
inline void TransXTimes::clear_times() {
  times_.Clear();
}
inline double TransXTimes::times(int index) const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXTimes.times)
  return times_.Get(index);
}
inline void TransXTimes::set_times(int index, double value) {
  times_.Set(index, value);
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXTimes.times)
}
inline void TransXTimes::add_times(double value) {
  times_.Add(value);
  // @@protoc_insertion_point(field_add:pagmo.problem.TransXTimes.times)
}
inline const ::google::protobuf::RepeatedField< double >&
TransXTimes::times() const {
  // @@protoc_insertion_point(field_list:pagmo.problem.TransXTimes.times)
  return times_;
}
inline ::google::protobuf::RepeatedField< double >*
TransXTimes::mutable_times() {
  // @@protoc_insertion_point(field_mutable_list:pagmo.problem.TransXTimes.times)
  return &times_;
}

// -------------------------------------------------------------------

// TransXEscape

// required double mjd = 1;
inline bool TransXEscape::has_mjd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransXEscape::set_has_mjd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransXEscape::clear_has_mjd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransXEscape::clear_mjd() {
  mjd_ = 0;
  clear_has_mjd();
}
inline double TransXEscape::mjd() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.mjd)
  return mjd_;
}
inline void TransXEscape::set_mjd(double value) {
  set_has_mjd();
  mjd_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.mjd)
}

// required double vinf = 2;
inline bool TransXEscape::has_vinf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransXEscape::set_has_vinf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransXEscape::clear_has_vinf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransXEscape::clear_vinf() {
  vinf_ = 0;
  clear_has_vinf();
}
inline double TransXEscape::vinf() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.vinf)
  return vinf_;
}
inline void TransXEscape::set_vinf(double value) {
  set_has_vinf();
  vinf_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.vinf)
}

// required double burn = 3;
inline bool TransXEscape::has_burn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransXEscape::set_has_burn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransXEscape::clear_has_burn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransXEscape::clear_burn() {
  burn_ = 0;
  clear_has_burn();
}
inline double TransXEscape::burn() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.burn)
  return burn_;
}
inline void TransXEscape::set_burn(double value) {
  set_has_burn();
  burn_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.burn)
}

// required double prograde = 4;
inline bool TransXEscape::has_prograde() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransXEscape::set_has_prograde() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransXEscape::clear_has_prograde() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransXEscape::clear_prograde() {
  prograde_ = 0;
  clear_has_prograde();
}
inline double TransXEscape::prograde() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.prograde)
  return prograde_;
}
inline void TransXEscape::set_prograde(double value) {
  set_has_prograde();
  prograde_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.prograde)
}

// required double outward = 5;
inline bool TransXEscape::has_outward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransXEscape::set_has_outward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransXEscape::clear_has_outward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransXEscape::clear_outward() {
  outward_ = 0;
  clear_has_outward();
}
inline double TransXEscape::outward() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.outward)
  return outward_;
}
inline void TransXEscape::set_outward(double value) {
  set_has_outward();
  outward_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.outward)
}

// required double plane = 6;
inline bool TransXEscape::has_plane() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransXEscape::set_has_plane() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransXEscape::clear_has_plane() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransXEscape::clear_plane() {
  plane_ = 0;
  clear_has_plane();
}
inline double TransXEscape::plane() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.plane)
  return plane_;
}
inline void TransXEscape::set_plane(double value) {
  set_has_plane();
  plane_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.plane)
}

// required string planet = 20;
inline bool TransXEscape::has_planet() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransXEscape::set_has_planet() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransXEscape::clear_has_planet() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransXEscape::clear_planet() {
  if (planet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_->clear();
  }
  clear_has_planet();
}
inline const ::std::string& TransXEscape::planet() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXEscape.planet)
  return *planet_;
}
inline void TransXEscape::set_planet(const ::std::string& value) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(value);
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXEscape.planet)
}
inline void TransXEscape::set_planet(const char* value) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(value);
  // @@protoc_insertion_point(field_set_char:pagmo.problem.TransXEscape.planet)
}
inline void TransXEscape::set_planet(const char* value, size_t size) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pagmo.problem.TransXEscape.planet)
}
inline ::std::string* TransXEscape::mutable_planet() {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXEscape.planet)
  return planet_;
}
inline ::std::string* TransXEscape::release_planet() {
  clear_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = planet_;
    planet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransXEscape::set_allocated_planet(::std::string* planet) {
  if (planet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete planet_;
  }
  if (planet) {
    set_has_planet();
    planet_ = planet;
  } else {
    clear_has_planet();
    planet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXEscape.planet)
}

// -------------------------------------------------------------------

// TransXDSM

// required double mjd = 1;
inline bool TransXDSM::has_mjd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransXDSM::set_has_mjd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransXDSM::clear_has_mjd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransXDSM::clear_mjd() {
  mjd_ = 0;
  clear_has_mjd();
}
inline double TransXDSM::mjd() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXDSM.mjd)
  return mjd_;
}
inline void TransXDSM::set_mjd(double value) {
  set_has_mjd();
  mjd_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXDSM.mjd)
}

// required double vinf = 2;
inline bool TransXDSM::has_vinf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransXDSM::set_has_vinf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransXDSM::clear_has_vinf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransXDSM::clear_vinf() {
  vinf_ = 0;
  clear_has_vinf();
}
inline double TransXDSM::vinf() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXDSM.vinf)
  return vinf_;
}
inline void TransXDSM::set_vinf(double value) {
  set_has_vinf();
  vinf_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXDSM.vinf)
}

// required double burn = 3;
inline bool TransXDSM::has_burn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransXDSM::set_has_burn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransXDSM::clear_has_burn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransXDSM::clear_burn() {
  burn_ = 0;
  clear_has_burn();
}
inline double TransXDSM::burn() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXDSM.burn)
  return burn_;
}
inline void TransXDSM::set_burn(double value) {
  set_has_burn();
  burn_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXDSM.burn)
}

// required double prograde = 4;
inline bool TransXDSM::has_prograde() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransXDSM::set_has_prograde() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransXDSM::clear_has_prograde() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransXDSM::clear_prograde() {
  prograde_ = 0;
  clear_has_prograde();
}
inline double TransXDSM::prograde() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXDSM.prograde)
  return prograde_;
}
inline void TransXDSM::set_prograde(double value) {
  set_has_prograde();
  prograde_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXDSM.prograde)
}

// required double outward = 5;
inline bool TransXDSM::has_outward() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransXDSM::set_has_outward() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransXDSM::clear_has_outward() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransXDSM::clear_outward() {
  outward_ = 0;
  clear_has_outward();
}
inline double TransXDSM::outward() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXDSM.outward)
  return outward_;
}
inline void TransXDSM::set_outward(double value) {
  set_has_outward();
  outward_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXDSM.outward)
}

// required double plane = 6;
inline bool TransXDSM::has_plane() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransXDSM::set_has_plane() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransXDSM::clear_has_plane() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransXDSM::clear_plane() {
  plane_ = 0;
  clear_has_plane();
}
inline double TransXDSM::plane() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXDSM.plane)
  return plane_;
}
inline void TransXDSM::set_plane(double value) {
  set_has_plane();
  plane_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXDSM.plane)
}

// -------------------------------------------------------------------

// TransXFlyBy

// required double mjd = 1;
inline bool TransXFlyBy::has_mjd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransXFlyBy::set_has_mjd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransXFlyBy::clear_has_mjd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransXFlyBy::clear_mjd() {
  mjd_ = 0;
  clear_has_mjd();
}
inline double TransXFlyBy::mjd() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.mjd)
  return mjd_;
}
inline void TransXFlyBy::set_mjd(double value) {
  set_has_mjd();
  mjd_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.mjd)
}

// required double burn = 3;
inline bool TransXFlyBy::has_burn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransXFlyBy::set_has_burn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransXFlyBy::clear_has_burn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransXFlyBy::clear_burn() {
  burn_ = 0;
  clear_has_burn();
}
inline double TransXFlyBy::burn() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.burn)
  return burn_;
}
inline void TransXFlyBy::set_burn(double value) {
  set_has_burn();
  burn_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.burn)
}

// required double prograde = 4;
inline bool TransXFlyBy::has_prograde() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransXFlyBy::set_has_prograde() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransXFlyBy::clear_has_prograde() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransXFlyBy::clear_prograde() {
  prograde_ = 0;
  clear_has_prograde();
}
inline double TransXFlyBy::prograde() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.prograde)
  return prograde_;
}
inline void TransXFlyBy::set_prograde(double value) {
  set_has_prograde();
  prograde_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.prograde)
}

// required double outward = 5;
inline bool TransXFlyBy::has_outward() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransXFlyBy::set_has_outward() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransXFlyBy::clear_has_outward() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransXFlyBy::clear_outward() {
  outward_ = 0;
  clear_has_outward();
}
inline double TransXFlyBy::outward() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.outward)
  return outward_;
}
inline void TransXFlyBy::set_outward(double value) {
  set_has_outward();
  outward_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.outward)
}

// required double plane = 6;
inline bool TransXFlyBy::has_plane() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransXFlyBy::set_has_plane() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransXFlyBy::clear_has_plane() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransXFlyBy::clear_plane() {
  plane_ = 0;
  clear_has_plane();
}
inline double TransXFlyBy::plane() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.plane)
  return plane_;
}
inline void TransXFlyBy::set_plane(double value) {
  set_has_plane();
  plane_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.plane)
}

// required double approach_vel = 7;
inline bool TransXFlyBy::has_approach_vel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TransXFlyBy::set_has_approach_vel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TransXFlyBy::clear_has_approach_vel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TransXFlyBy::clear_approach_vel() {
  approach_vel_ = 0;
  clear_has_approach_vel();
}
inline double TransXFlyBy::approach_vel() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.approach_vel)
  return approach_vel_;
}
inline void TransXFlyBy::set_approach_vel(double value) {
  set_has_approach_vel();
  approach_vel_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.approach_vel)
}

// required double departure_vel = 8;
inline bool TransXFlyBy::has_departure_vel() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TransXFlyBy::set_has_departure_vel() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TransXFlyBy::clear_has_departure_vel() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TransXFlyBy::clear_departure_vel() {
  departure_vel_ = 0;
  clear_has_departure_vel();
}
inline double TransXFlyBy::departure_vel() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.departure_vel)
  return departure_vel_;
}
inline void TransXFlyBy::set_departure_vel(double value) {
  set_has_departure_vel();
  departure_vel_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.departure_vel)
}

// required double outward_angle = 9;
inline bool TransXFlyBy::has_outward_angle() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransXFlyBy::set_has_outward_angle() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransXFlyBy::clear_has_outward_angle() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransXFlyBy::clear_outward_angle() {
  outward_angle_ = 0;
  clear_has_outward_angle();
}
inline double TransXFlyBy::outward_angle() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.outward_angle)
  return outward_angle_;
}
inline void TransXFlyBy::set_outward_angle(double value) {
  set_has_outward_angle();
  outward_angle_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.outward_angle)
}

// required double inclination = 10;
inline bool TransXFlyBy::has_inclination() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TransXFlyBy::set_has_inclination() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TransXFlyBy::clear_has_inclination() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TransXFlyBy::clear_inclination() {
  inclination_ = 0;
  clear_has_inclination();
}
inline double TransXFlyBy::inclination() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.inclination)
  return inclination_;
}
inline void TransXFlyBy::set_inclination(double value) {
  set_has_inclination();
  inclination_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.inclination)
}

// required double turning_angle = 11;
inline bool TransXFlyBy::has_turning_angle() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TransXFlyBy::set_has_turning_angle() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TransXFlyBy::clear_has_turning_angle() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TransXFlyBy::clear_turning_angle() {
  turning_angle_ = 0;
  clear_has_turning_angle();
}
inline double TransXFlyBy::turning_angle() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.turning_angle)
  return turning_angle_;
}
inline void TransXFlyBy::set_turning_angle(double value) {
  set_has_turning_angle();
  turning_angle_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.turning_angle)
}

// required double periapsis_altitude = 12;
inline bool TransXFlyBy::has_periapsis_altitude() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TransXFlyBy::set_has_periapsis_altitude() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TransXFlyBy::clear_has_periapsis_altitude() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TransXFlyBy::clear_periapsis_altitude() {
  periapsis_altitude_ = 0;
  clear_has_periapsis_altitude();
}
inline double TransXFlyBy::periapsis_altitude() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.periapsis_altitude)
  return periapsis_altitude_;
}
inline void TransXFlyBy::set_periapsis_altitude(double value) {
  set_has_periapsis_altitude();
  periapsis_altitude_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.periapsis_altitude)
}

// required string planet = 20;
inline bool TransXFlyBy::has_planet() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TransXFlyBy::set_has_planet() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TransXFlyBy::clear_has_planet() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TransXFlyBy::clear_planet() {
  if (planet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_->clear();
  }
  clear_has_planet();
}
inline const ::std::string& TransXFlyBy::planet() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXFlyBy.planet)
  return *planet_;
}
inline void TransXFlyBy::set_planet(const ::std::string& value) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(value);
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXFlyBy.planet)
}
inline void TransXFlyBy::set_planet(const char* value) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(value);
  // @@protoc_insertion_point(field_set_char:pagmo.problem.TransXFlyBy.planet)
}
inline void TransXFlyBy::set_planet(const char* value, size_t size) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pagmo.problem.TransXFlyBy.planet)
}
inline ::std::string* TransXFlyBy::mutable_planet() {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXFlyBy.planet)
  return planet_;
}
inline ::std::string* TransXFlyBy::release_planet() {
  clear_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = planet_;
    planet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransXFlyBy::set_allocated_planet(::std::string* planet) {
  if (planet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete planet_;
  }
  if (planet) {
    set_has_planet();
    planet_ = planet;
  } else {
    clear_has_planet();
    planet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXFlyBy.planet)
}

// -------------------------------------------------------------------

// TransXArrival

// required double mjd = 1;
inline bool TransXArrival::has_mjd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TransXArrival::set_has_mjd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TransXArrival::clear_has_mjd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TransXArrival::clear_mjd() {
  mjd_ = 0;
  clear_has_mjd();
}
inline double TransXArrival::mjd() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXArrival.mjd)
  return mjd_;
}
inline void TransXArrival::set_mjd(double value) {
  set_has_mjd();
  mjd_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXArrival.mjd)
}

// required double vinf = 2;
inline bool TransXArrival::has_vinf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransXArrival::set_has_vinf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransXArrival::clear_has_vinf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransXArrival::clear_vinf() {
  vinf_ = 0;
  clear_has_vinf();
}
inline double TransXArrival::vinf() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXArrival.vinf)
  return vinf_;
}
inline void TransXArrival::set_vinf(double value) {
  set_has_vinf();
  vinf_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXArrival.vinf)
}

// required double burn = 3;
inline bool TransXArrival::has_burn() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransXArrival::set_has_burn() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransXArrival::clear_has_burn() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransXArrival::clear_burn() {
  burn_ = 0;
  clear_has_burn();
}
inline double TransXArrival::burn() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXArrival.burn)
  return burn_;
}
inline void TransXArrival::set_burn(double value) {
  set_has_burn();
  burn_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXArrival.burn)
}

// required string planet = 20;
inline bool TransXArrival::has_planet() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransXArrival::set_has_planet() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransXArrival::clear_has_planet() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransXArrival::clear_planet() {
  if (planet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_->clear();
  }
  clear_has_planet();
}
inline const ::std::string& TransXArrival::planet() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXArrival.planet)
  return *planet_;
}
inline void TransXArrival::set_planet(const ::std::string& value) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(value);
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXArrival.planet)
}
inline void TransXArrival::set_planet(const char* value) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(value);
  // @@protoc_insertion_point(field_set_char:pagmo.problem.TransXArrival.planet)
}
inline void TransXArrival::set_planet(const char* value, size_t size) {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  planet_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pagmo.problem.TransXArrival.planet)
}
inline ::std::string* TransXArrival::mutable_planet() {
  set_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    planet_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXArrival.planet)
  return planet_;
}
inline ::std::string* TransXArrival::release_planet() {
  clear_has_planet();
  if (planet_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = planet_;
    planet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransXArrival::set_allocated_planet(::std::string* planet) {
  if (planet_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete planet_;
  }
  if (planet) {
    set_has_planet();
    planet_ = planet;
  } else {
    clear_has_planet();
    planet_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXArrival.planet)
}

// -------------------------------------------------------------------

// TransXSolution

// repeated double x = 1;
inline int TransXSolution::x_size() const {
  return x_.size();
}
inline void TransXSolution::clear_x() {
  x_.Clear();
}
inline double TransXSolution::x(int index) const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.x)
  return x_.Get(index);
}
inline void TransXSolution::set_x(int index, double value) {
  x_.Set(index, value);
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXSolution.x)
}
inline void TransXSolution::add_x(double value) {
  x_.Add(value);
  // @@protoc_insertion_point(field_add:pagmo.problem.TransXSolution.x)
}
inline const ::google::protobuf::RepeatedField< double >&
TransXSolution::x() const {
  // @@protoc_insertion_point(field_list:pagmo.problem.TransXSolution.x)
  return x_;
}
inline ::google::protobuf::RepeatedField< double >*
TransXSolution::mutable_x() {
  // @@protoc_insertion_point(field_mutable_list:pagmo.problem.TransXSolution.x)
  return &x_;
}

// required string problem = 2;
inline bool TransXSolution::has_problem() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TransXSolution::set_has_problem() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TransXSolution::clear_has_problem() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TransXSolution::clear_problem() {
  if (problem_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    problem_->clear();
  }
  clear_has_problem();
}
inline const ::std::string& TransXSolution::problem() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.problem)
  return *problem_;
}
inline void TransXSolution::set_problem(const ::std::string& value) {
  set_has_problem();
  if (problem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    problem_ = new ::std::string;
  }
  problem_->assign(value);
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXSolution.problem)
}
inline void TransXSolution::set_problem(const char* value) {
  set_has_problem();
  if (problem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    problem_ = new ::std::string;
  }
  problem_->assign(value);
  // @@protoc_insertion_point(field_set_char:pagmo.problem.TransXSolution.problem)
}
inline void TransXSolution::set_problem(const char* value, size_t size) {
  set_has_problem();
  if (problem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    problem_ = new ::std::string;
  }
  problem_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pagmo.problem.TransXSolution.problem)
}
inline ::std::string* TransXSolution::mutable_problem() {
  set_has_problem();
  if (problem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    problem_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXSolution.problem)
  return problem_;
}
inline ::std::string* TransXSolution::release_problem() {
  clear_has_problem();
  if (problem_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = problem_;
    problem_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TransXSolution::set_allocated_problem(::std::string* problem) {
  if (problem_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete problem_;
  }
  if (problem) {
    set_has_problem();
    problem_ = problem;
  } else {
    clear_has_problem();
    problem_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXSolution.problem)
}

// required double fuel_cost = 3;
inline bool TransXSolution::has_fuel_cost() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TransXSolution::set_has_fuel_cost() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TransXSolution::clear_has_fuel_cost() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TransXSolution::clear_fuel_cost() {
  fuel_cost_ = 0;
  clear_has_fuel_cost();
}
inline double TransXSolution::fuel_cost() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.fuel_cost)
  return fuel_cost_;
}
inline void TransXSolution::set_fuel_cost(double value) {
  set_has_fuel_cost();
  fuel_cost_ = value;
  // @@protoc_insertion_point(field_set:pagmo.problem.TransXSolution.fuel_cost)
}

// required .pagmo.problem.TransXTimes times = 4;
inline bool TransXSolution::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TransXSolution::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TransXSolution::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TransXSolution::clear_times() {
  if (times_ != NULL) times_->::pagmo::problem::TransXTimes::Clear();
  clear_has_times();
}
inline const ::pagmo::problem::TransXTimes& TransXSolution::times() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.times)
  return times_ != NULL ? *times_ : *default_instance_->times_;
}
inline ::pagmo::problem::TransXTimes* TransXSolution::mutable_times() {
  set_has_times();
  if (times_ == NULL) times_ = new ::pagmo::problem::TransXTimes;
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXSolution.times)
  return times_;
}
inline ::pagmo::problem::TransXTimes* TransXSolution::release_times() {
  clear_has_times();
  ::pagmo::problem::TransXTimes* temp = times_;
  times_ = NULL;
  return temp;
}
inline void TransXSolution::set_allocated_times(::pagmo::problem::TransXTimes* times) {
  delete times_;
  times_ = times;
  if (times) {
    set_has_times();
  } else {
    clear_has_times();
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXSolution.times)
}

// required .pagmo.problem.TransXEscape escape = 5;
inline bool TransXSolution::has_escape() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TransXSolution::set_has_escape() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TransXSolution::clear_has_escape() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TransXSolution::clear_escape() {
  if (escape_ != NULL) escape_->::pagmo::problem::TransXEscape::Clear();
  clear_has_escape();
}
inline const ::pagmo::problem::TransXEscape& TransXSolution::escape() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.escape)
  return escape_ != NULL ? *escape_ : *default_instance_->escape_;
}
inline ::pagmo::problem::TransXEscape* TransXSolution::mutable_escape() {
  set_has_escape();
  if (escape_ == NULL) escape_ = new ::pagmo::problem::TransXEscape;
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXSolution.escape)
  return escape_;
}
inline ::pagmo::problem::TransXEscape* TransXSolution::release_escape() {
  clear_has_escape();
  ::pagmo::problem::TransXEscape* temp = escape_;
  escape_ = NULL;
  return temp;
}
inline void TransXSolution::set_allocated_escape(::pagmo::problem::TransXEscape* escape) {
  delete escape_;
  escape_ = escape;
  if (escape) {
    set_has_escape();
  } else {
    clear_has_escape();
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXSolution.escape)
}

// repeated .pagmo.problem.TransXDSM dsms = 6;
inline int TransXSolution::dsms_size() const {
  return dsms_.size();
}
inline void TransXSolution::clear_dsms() {
  dsms_.Clear();
}
inline const ::pagmo::problem::TransXDSM& TransXSolution::dsms(int index) const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.dsms)
  return dsms_.Get(index);
}
inline ::pagmo::problem::TransXDSM* TransXSolution::mutable_dsms(int index) {
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXSolution.dsms)
  return dsms_.Mutable(index);
}
inline ::pagmo::problem::TransXDSM* TransXSolution::add_dsms() {
  // @@protoc_insertion_point(field_add:pagmo.problem.TransXSolution.dsms)
  return dsms_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXDSM >&
TransXSolution::dsms() const {
  // @@protoc_insertion_point(field_list:pagmo.problem.TransXSolution.dsms)
  return dsms_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXDSM >*
TransXSolution::mutable_dsms() {
  // @@protoc_insertion_point(field_mutable_list:pagmo.problem.TransXSolution.dsms)
  return &dsms_;
}

// repeated .pagmo.problem.TransXFlyBy flybyes = 7;
inline int TransXSolution::flybyes_size() const {
  return flybyes_.size();
}
inline void TransXSolution::clear_flybyes() {
  flybyes_.Clear();
}
inline const ::pagmo::problem::TransXFlyBy& TransXSolution::flybyes(int index) const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.flybyes)
  return flybyes_.Get(index);
}
inline ::pagmo::problem::TransXFlyBy* TransXSolution::mutable_flybyes(int index) {
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXSolution.flybyes)
  return flybyes_.Mutable(index);
}
inline ::pagmo::problem::TransXFlyBy* TransXSolution::add_flybyes() {
  // @@protoc_insertion_point(field_add:pagmo.problem.TransXSolution.flybyes)
  return flybyes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXFlyBy >&
TransXSolution::flybyes() const {
  // @@protoc_insertion_point(field_list:pagmo.problem.TransXSolution.flybyes)
  return flybyes_;
}
inline ::google::protobuf::RepeatedPtrField< ::pagmo::problem::TransXFlyBy >*
TransXSolution::mutable_flybyes() {
  // @@protoc_insertion_point(field_mutable_list:pagmo.problem.TransXSolution.flybyes)
  return &flybyes_;
}

// required .pagmo.problem.TransXArrival arrival = 8;
inline bool TransXSolution::has_arrival() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TransXSolution::set_has_arrival() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TransXSolution::clear_has_arrival() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TransXSolution::clear_arrival() {
  if (arrival_ != NULL) arrival_->::pagmo::problem::TransXArrival::Clear();
  clear_has_arrival();
}
inline const ::pagmo::problem::TransXArrival& TransXSolution::arrival() const {
  // @@protoc_insertion_point(field_get:pagmo.problem.TransXSolution.arrival)
  return arrival_ != NULL ? *arrival_ : *default_instance_->arrival_;
}
inline ::pagmo::problem::TransXArrival* TransXSolution::mutable_arrival() {
  set_has_arrival();
  if (arrival_ == NULL) arrival_ = new ::pagmo::problem::TransXArrival;
  // @@protoc_insertion_point(field_mutable:pagmo.problem.TransXSolution.arrival)
  return arrival_;
}
inline ::pagmo::problem::TransXArrival* TransXSolution::release_arrival() {
  clear_has_arrival();
  ::pagmo::problem::TransXArrival* temp = arrival_;
  arrival_ = NULL;
  return temp;
}
inline void TransXSolution::set_allocated_arrival(::pagmo::problem::TransXArrival* arrival) {
  delete arrival_;
  arrival_ = arrival;
  if (arrival) {
    set_has_arrival();
  } else {
    clear_has_arrival();
  }
  // @@protoc_insertion_point(field_set_allocated:pagmo.problem.TransXSolution.arrival)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace problem
}  // namespace pagmo

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_solution_2eproto__INCLUDED
